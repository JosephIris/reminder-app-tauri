<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Reminder Bar</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      html {
        height: 100%;
      }

      body {
        background: linear-gradient(
          180deg,
          rgba(32, 32, 36, 0.97) 0%,
          rgba(24, 24, 28, 0.98) 100%
        );
        font-family: 'Segoe UI Variable', 'Segoe UI', system-ui, sans-serif;
        overflow: hidden;
        user-select: none;
        height: 100%;
        width: 100%;
        display: flex;
        align-items: center;
        justify-content: flex-start;
        padding: 0 16px;
        gap: 10px;
      }

      /* Stats section on the right */
      .stats-section {
        position: fixed;
        right: 16px;
        top: 50%;
        transform: translateY(-50%);
        display: flex;
        align-items: center;
        gap: 12px;
        padding: 6px 12px;
        background: rgba(255, 255, 255, 0.03);
        border-radius: 8px;
        border: 1px solid rgba(255, 255, 255, 0.05);
      }

      .stat-item {
        display: flex;
        align-items: center;
        gap: 4px;
        font-size: 11px;
        color: rgba(255, 255, 255, 0.4);
      }

      .stat-item .count {
        font-weight: 600;
      }

      .stat-item.today .count {
        color: #4ade80;
      }

      .stat-item.week .count {
        color: #60a5fa;
      }

      /* Urgency colors */
      .urgency-now { color: #f87171; }
      .urgency-today { color: #fbbf24; }
      .urgency-soon { color: #facc15; }
      .urgency-whenever { color: #9ca3af; }

      .urgency-badge {
        font-size: 9px;
        font-weight: 600;
        text-transform: uppercase;
        letter-spacing: 0.5px;
        padding: 2px 6px;
        border-radius: 4px;
        background: rgba(255, 255, 255, 0.05);
      }

      .reminder-card {
        position: relative;
        flex-shrink: 0;
        background: linear-gradient(
          180deg,
          rgba(255, 255, 255, 0.065) 0%,
          rgba(255, 255, 255, 0.035) 100%
        );
        border: 2px solid transparent;
        border-radius: 8px;
        padding: 8px 14px;
        display: flex;
        align-items: center;
        gap: 8px;
        min-width: 80px;
        max-width: 280px;
        height: 44px;
        cursor: grab;
        overflow: visible;
        box-shadow:
          inset 0 1px 0 rgba(255, 255, 255, 0.07),
          0 2px 4px rgba(0, 0, 0, 0.12),
          0 1px 2px rgba(0, 0, 0, 0.08);
        transition: transform 0.15s ease, box-shadow 0.15s ease, background 0.15s ease;
        isolation: isolate;
      }

      .reminder-card:hover {
        background: linear-gradient(
          180deg,
          rgba(255, 255, 255, 0.09) 0%,
          rgba(255, 255, 255, 0.05) 100%
        );
        box-shadow:
          inset 0 1px 0 rgba(255, 255, 255, 0.1),
          0 4px 8px rgba(0, 0, 0, 0.18),
          0 2px 4px rgba(0, 0, 0, 0.12);
        transform: translateY(-2px);
      }

      body.dragging-active .reminder-card:hover {
        background: linear-gradient(
          180deg,
          rgba(255, 255, 255, 0.065) 0%,
          rgba(255, 255, 255, 0.035) 100%
        );
        transform: none;
        box-shadow:
          inset 0 1px 0 rgba(255, 255, 255, 0.07),
          0 2px 4px rgba(0, 0, 0, 0.12);
      }

      body.dragging-active .card-btn:hover {
        background: rgba(255, 255, 255, 0.04);
        color: rgba(255, 255, 255, 0.5);
      }

      .reminder-card.dragging {
        opacity: 0.9;
        cursor: grabbing;
        box-shadow: 0 8px 24px rgba(0, 0, 0, 0.35);
      }

      .reminder-card.active {
        border-color: #8b5cf6;
        box-shadow:
          inset 0 1px 0 rgba(255, 255, 255, 0.08),
          0 0 0 1px #6366f1,
          0 0 12px rgba(139, 92, 246, 0.5),
          0 0 24px rgba(99, 102, 241, 0.3);
        animation: border-glow 2s ease-in-out infinite alternate;
      }

      @keyframes border-glow {
        from {
          border-color: #8b5cf6;
          box-shadow:
            inset 0 1px 0 rgba(255, 255, 255, 0.08),
            0 0 0 1px #6366f1,
            0 0 12px rgba(139, 92, 246, 0.5),
            0 0 24px rgba(99, 102, 241, 0.3);
        }
        to {
          border-color: #06b6d4;
          box-shadow:
            inset 0 1px 0 rgba(255, 255, 255, 0.08),
            0 0 0 1px #3b82f6,
            0 0 12px rgba(6, 182, 212, 0.5),
            0 0 24px rgba(59, 130, 246, 0.3);
        }
      }

      .reminder-card.active .card-message {
        font-size: 14px;
        white-space: nowrap;
        overflow: visible;
        text-overflow: clip;
      }

      .reminder-card.active .card-btn {
        width: 32px;
        height: 32px;
        font-size: 13px;
      }

      .reminder-card.hover-expanded .card-message,
      .reminder-card.hover-controls .card-message {
        white-space: nowrap;
        overflow: visible;
        text-overflow: clip;
      }

      .card-content {
        flex: 1;
        min-width: 0;
        display: flex;
        flex-direction: column;
        gap: 2px;
      }

      .card-message {
        color: #fafafa;
        font-size: 12px;
        font-weight: 500;
        white-space: nowrap;
        overflow: visible;
        transition: font-size 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      }

      .card-urgency {
        display: none;
        opacity: 0;
        transform: translateY(-4px);
      }

      .card-actions {
        display: flex;
        gap: 4px;
        opacity: 0;
        transform: translateX(8px);
        pointer-events: none;
        width: 0;
        overflow: hidden;
        flex-shrink: 0;
      }

      .reminder-card.hover-controls .card-actions,
      .reminder-card.active .card-actions {
        width: auto;
        pointer-events: auto;
      }

      .card-btn {
        border: none;
        background: rgba(255, 255, 255, 0.05);
        color: rgba(255, 255, 255, 0.55);
        width: 28px;
        height: 28px;
        border-radius: 6px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 12px;
        transition: all 0.12s ease;
      }

      .card-btn:hover {
        background: rgba(255, 255, 255, 0.1);
        color: rgba(255, 255, 255, 0.9);
      }

      .card-btn:active {
        transform: scale(0.94);
      }

      .card-btn.complete:hover {
        background: rgba(34, 197, 94, 0.2);
        color: #4ade80;
      }

      .card-btn.dismiss:hover {
        background: rgba(239, 68, 68, 0.2);
        color: #f87171;
      }

      .drag-ghost {
        position: fixed;
        pointer-events: none;
        z-index: 10000;
        opacity: 0.9;
        transform: rotate(2deg);
        box-shadow: 0 8px 24px rgba(0, 0, 0, 0.4);
      }

      .reminder-card.being-dragged {
        opacity: 0.3;
      }

      .drag-placeholder {
        flex-shrink: 0;
        min-width: 100px;
        height: 44px;
        background: rgba(99, 102, 241, 0.1);
        border: 2px dashed rgba(99, 102, 241, 0.4);
        border-radius: 8px;
        margin: 0 4px;
      }

      .empty-state {
        display: flex;
        align-items: center;
        gap: 12px;
        color: rgba(255, 255, 255, 0.5);
        font-size: 12px;
        padding: 0 8px;
        font-weight: 400;
      }

      .empty-state-text {
        display: flex;
        flex-direction: column;
        gap: 2px;
      }

      .empty-state-title {
        color: rgba(255, 255, 255, 0.7);
        font-weight: 500;
      }

      .empty-state-hint {
        color: rgba(255, 255, 255, 0.4);
        font-size: 11px;
      }

      .empty-state-btn {
        background: rgba(99, 102, 241, 0.2);
        border: 1px solid rgba(99, 102, 241, 0.3);
        color: #818cf8;
        padding: 6px 12px;
        border-radius: 6px;
        font-size: 11px;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.15s ease;
      }

      .empty-state-btn:hover {
        background: rgba(99, 102, 241, 0.3);
        border-color: rgba(99, 102, 241, 0.5);
        color: #a5b4fc;
      }

      .tooltip {
        position: fixed;
        background: rgba(40, 40, 46, 0.97);
        border: 1px solid rgba(255, 255, 255, 0.08);
        border-radius: 8px;
        padding: 10px 14px;
        z-index: 10000;
        pointer-events: none;
        max-width: 400px;
        box-shadow:
          0 4px 20px rgba(0, 0, 0, 0.35),
          inset 0 1px 0 rgba(255, 255, 255, 0.05);
        display: flex;
        align-items: center;
        gap: 14px;
      }

      .tooltip-message {
        color: rgba(255, 255, 255, 0.9);
        font-size: 12px;
        font-weight: 500;
        word-wrap: break-word;
      }

      .tooltip-urgency {
        font-size: 10px;
        white-space: nowrap;
      }
    </style>
  </head>
  <body>
    <div class="empty-state">
      <div class="empty-state-text">
        <span class="empty-state-title">Ready to focus</span>
        <span class="empty-state-hint">Add tasks to get started</span>
      </div>
      <button class="empty-state-btn" id="open-list-btn">Open List</button>
    </div>
    <div class="stats-section">
      <div class="stat-item today">
        <span class="count" id="stats-today">0</span>
        <span>today</span>
      </div>
      <div class="stat-item week">
        <span class="count" id="stats-week">0</span>
        <span>week</span>
      </div>
    </div>

    <script src="motion.js"></script>
    <script>
      if (typeof Motion === 'undefined') {
        console.error("[BAR] FATAL: Motion One not loaded!");
      }

      const { animate, spring } = Motion;
      const { invoke } = window.__TAURI__.core;
      const { listen, emit } = window.__TAURI__.event;

      // Warm up animations
      (function warmupAnimations() {
        const dummy = document.createElement('div');
        dummy.style.cssText = 'position:absolute;left:-9999px;width:100px;height:40px;opacity:1;';
        document.body.appendChild(dummy);

        let iteration = 0;
        function runWarmup() {
          animate(dummy, { width: iteration % 2 === 0 ? '200px' : '100px' }, {
            type: spring,
            stiffness: 225,
            damping: 25
          });
          iteration++;
          if (iteration < 3) {
            requestAnimationFrame(runWarmup);
          } else {
            setTimeout(() => dummy.remove(), 300);
          }
        }
        runWarmup();
      })();

      let reminders = [];
      let orderedIds = [];
      let focusedId = null;
      let ignoreNextFocusEvent = false;
      let draggedId = null;
      let dragStartX = 0;
      let dragOffsetX = 0;
      let isDragging = false;
      let justFinishedDrag = false;
      let tooltipEl = null;
      let ghostEl = null;
      let placeholderEl = null;
      let dropTargetIndex = -1;

      const hoverTimers = new Map();
      let cleanupFns = [];
      let pollInterval = null;

      const urgencyConfig = {
        now: { label: 'NOW', class: 'urgency-now' },
        today: { label: 'Today', class: 'urgency-today' },
        soon: { label: 'Soon', class: 'urgency-soon' },
        whenever: { label: '', class: 'urgency-whenever' }
      };

      function cleanup() {
        cleanupFns.forEach(fn => { try { fn(); } catch (e) {} });
        cleanupFns = [];
        if (pollInterval) {
          clearInterval(pollInterval);
          pollInterval = null;
        }
        hoverTimers.forEach((timers, id) => {
          clearTimeout(timers.expandTimer);
          clearTimeout(timers.controlsTimer);
        });
        hoverTimers.clear();
        document.removeEventListener('mousemove', handleDragMove);
        document.removeEventListener('mouseup', handleDragEnd);
      }

      window.addEventListener('beforeunload', cleanup);

      const cardConfigs = {
        // Auto-width: cards show full text up to maxWidth
        compact: { minWidth: 80, maxWidth: 280, height: 44 },
        expanded: { minWidth: 120, maxWidth: 400, height: 44 },
        focused: { minWidth: 200, maxWidth: 500, height: 50 }
      };

      const measureCanvas = document.createElement('canvas');
      const measureCtx = measureCanvas.getContext('2d');

      function measureTextWidth(text, fontSize = 12) {
        measureCtx.font = `500 ${fontSize}px 'Segoe UI', system-ui, sans-serif`;
        return measureCtx.measureText(text).width;
      }

      function calculateCardWidth(message, state) {
        const config = cardConfigs[state] || cardConfigs.compact;
        const fontSize = state === 'focused' ? 14 : 12;
        const textWidth = measureTextWidth(message, fontSize);
        let padding = 40;

        if (state === 'focused') {
          const controlsWidth = 80;
          const idealWidth = textWidth + padding + controlsWidth;
          return Math.min(Math.max(idealWidth, config.minWidth), config.maxWidth);
        }

        // All states now show full text (auto-width based on content)
        const idealWidth = textWidth + padding;
        return Math.min(Math.max(idealWidth, config.minWidth), config.maxWidth);
      }

      function setCardState(card, state, message) {
        const config = cardConfigs[state] || cardConfigs.compact;
        const width = calculateCardWidth(message, state);
        card.style.width = width + 'px';
        card.style.minWidth = cardConfigs.compact.minWidth + 'px';
        card.style.maxWidth = config.maxWidth + 'px';
        card.style.height = config.height + 'px';
      }

      function animateCardExpand(card, state, message) {
        const config = cardConfigs[state] || cardConfigs.compact;
        const width = calculateCardWidth(message, state);
        try {
          animate(card, {
            width: width + 'px',
            height: config.height + 'px'
          }, {
            type: spring,
            stiffness: 225,
            damping: 25
          });
        } catch (err) {
          card.style.width = width + 'px';
          card.style.height = config.height + 'px';
        }
      }

      function animateActionsIn(actions) {
        actions.style.width = 'auto';
        actions.style.transform = 'none';
        animate(actions, { opacity: 1 }, { duration: 0.2, easing: 'ease-out' });
      }

      function animateActionsOut(actions) {
        animate(actions, { opacity: 0 }, { duration: 0.15, easing: 'ease-out' })
          .finished.then(() => { actions.style.width = '0'; });
      }

      function animateUrgencyIn(urgency) {
        urgency.style.display = 'block';
        animate(urgency, { opacity: 1, transform: 'translateY(0px)' }, {
          type: spring, stiffness: 200, damping: 20
        });
      }

      function animateUrgencyOut(urgency) {
        animate(urgency, { opacity: 0, transform: 'translateY(-4px)' }, {
          type: spring, stiffness: 200, damping: 20
        }).finished.then(() => { urgency.style.display = 'none'; });
      }

      function animateFocusIn(card) {
        animate(card, { transform: 'scale(1.01)' }, { type: spring, stiffness: 300, damping: 30 });
      }

      function animateFocusOut(card) {
        animate(card, { transform: 'scale(1)' }, { type: spring, stiffness: 300, damping: 30 });
      }

      function animateButtonPress(btn) {
        animate(btn, { transform: 'scale(0.92)' }, { duration: 0.1 })
          .finished.then(() => {
            animate(btn, { transform: 'scale(1)' }, { type: spring, stiffness: 400, damping: 15 });
          });
      }

      function createTooltip() {
        if (!tooltipEl) {
          tooltipEl = document.createElement('div');
          tooltipEl.className = 'tooltip';
          tooltipEl.style.display = 'none';
          document.body.appendChild(tooltipEl);
        }
      }
      createTooltip();

      function showTooltip(reminder, x, y) {
        if (!tooltipEl || isDragging) return;
        const urg = urgencyConfig[reminder.urgency] || urgencyConfig.whenever;
        tooltipEl.innerHTML = `
          <span class="tooltip-message">${escapeHtml(reminder.message)}</span>
          <span class="tooltip-urgency ${urg.class}">${urg.label}</span>
        `;
        tooltipEl.style.left = Math.min(Math.max(x - 100, 8), window.innerWidth - 420) + 'px';
        tooltipEl.style.top = '8px';
        tooltipEl.style.display = 'flex';
      }

      function hideTooltip() {
        if (tooltipEl) tooltipEl.style.display = 'none';
      }

      function escapeHtml(str) {
        const div = document.createElement('div');
        div.textContent = str;
        return div.innerHTML;
      }

      async function handleComplete(id) {
        await invoke("complete_reminder", { id });
        await emit("refresh-reminders");
      }

      async function handleDismiss(id) {
        await invoke("delete_reminder", { id });
        await emit("refresh-reminders");
      }

      async function handleFocus(id) {
        focusedId = focusedId === id ? null : id;
        render();
        ignoreNextFocusEvent = true;
        await emit("focus-reminder", { id: focusedId });
      }

      function calculateWidthWithControls(message) {
        const textWidth = measureTextWidth(message, 12);
        const idealWidth = textWidth + 40 + 80;
        return Math.min(Math.max(idealWidth, 200), 600);
      }

      function startHoverTimers(card, reminder) {
        const id = reminder.id;
        const message = reminder.message;
        clearHoverTimers(id);

        const urgency = card.querySelector('.card-urgency');
        const actions = card.querySelector('.card-actions');

        const timers = {
          expandTimer: setTimeout(() => {
            if (!isDragging && focusedId !== id) {
              card.classList.add('hover-expanded');
              animateCardExpand(card, 'expanded', message);
              if (urgency) animateUrgencyIn(urgency);
            }
          }, 500),
          controlsTimer: setTimeout(() => {
            if (!isDragging && focusedId !== id) {
              card.classList.add('hover-controls');
              const widthWithControls = calculateWidthWithControls(message);
              animate(card, { width: widthWithControls + 'px' }, {
                type: spring, stiffness: 225, damping: 25
              }).finished.then(() => {
                if (actions && card.classList.contains('hover-controls')) {
                  animateActionsIn(actions);
                }
              });
            }
          }, 1000)
        };

        hoverTimers.set(id, timers);
      }

      function clearHoverTimers(id) {
        const timers = hoverTimers.get(id);
        if (timers) {
          clearTimeout(timers.expandTimer);
          clearTimeout(timers.controlsTimer);
          hoverTimers.delete(id);
        }
      }

      function clearHoverState(card, id) {
        clearHoverTimers(id);
        const wasExpanded = card.classList.contains('hover-expanded');
        const hadControls = card.classList.contains('hover-controls');

        card.classList.remove('hover-expanded', 'hover-controls');

        if (wasExpanded || hadControls) {
          const urgency = card.querySelector('.card-urgency');
          const actions = card.querySelector('.card-actions');
          const message = card.dataset.message || '';

          animateCardExpand(card, 'compact', message);
          if (urgency) animateUrgencyOut(urgency);
          if (actions) animateActionsOut(actions);
        }
      }

      function handleDragStart(e, id) {
        draggedId = id;
        dragStartX = e.clientX;
        isDragging = false;
        hideTooltip();

        const card = e.target.closest('.reminder-card');
        const rect = card.getBoundingClientRect();
        dragOffsetX = e.clientX - rect.left;

        document.body.style.cursor = 'grabbing';
      }

      function createGhost(card) {
        ghostEl = card.cloneNode(true);
        ghostEl.className = 'reminder-card drag-ghost';
        document.body.appendChild(ghostEl);
        document.body.classList.add('dragging-active');
        card.classList.add('being-dragged');
      }

      function removeGhost() {
        if (ghostEl) {
          ghostEl.remove();
          ghostEl = null;
        }
        document.body.classList.remove('dragging-active');
        const dragged = document.querySelector('.being-dragged');
        if (dragged) dragged.classList.remove('being-dragged');
      }

      function createPlaceholder() {
        if (!placeholderEl) {
          placeholderEl = document.createElement('div');
          placeholderEl.className = 'drag-placeholder';
        }
        return placeholderEl;
      }

      function removePlaceholder() {
        if (placeholderEl && placeholderEl.parentNode) placeholderEl.remove();
      }

      function handleDragMove(e) {
        if (draggedId === null) return;

        if (!isDragging && Math.abs(e.clientX - dragStartX) > 5) {
          isDragging = true;
          const card = document.querySelector(`.reminder-card[data-id="${draggedId}"]`);
          if (card) createGhost(card);
        }

        if (!isDragging) return;

        if (ghostEl) {
          ghostEl.style.left = (e.clientX - dragOffsetX) + 'px';
          ghostEl.style.top = (e.clientY - 20) + 'px';
        }

        const cards = Array.from(document.body.querySelectorAll('.reminder-card:not(.being-dragged)'));
        let newDropIndex = orderedIds.length;

        for (let i = 0; i < cards.length; i++) {
          const card = cards[i];
          const rect = card.getBoundingClientRect();
          const midX = rect.left + rect.width / 2;

          if (e.clientX < midX) {
            newDropIndex = orderedIds.indexOf(parseInt(card.dataset.id));
            break;
          }
        }

        const draggedIndex = orderedIds.indexOf(draggedId);
        if (newDropIndex > draggedIndex) newDropIndex--;

        if (newDropIndex !== dropTargetIndex) {
          dropTargetIndex = newDropIndex;
          removePlaceholder();

          const placeholder = createPlaceholder();
          const allCards = Array.from(document.body.querySelectorAll('.reminder-card'));

          let insertBeforeEl = null;
          let count = 0;
          for (const c of allCards) {
            if (c.classList.contains('being-dragged')) continue;
            if (count === dropTargetIndex) {
              insertBeforeEl = c;
              break;
            }
            count++;
          }

          if (insertBeforeEl) {
            document.body.insertBefore(placeholder, insertBeforeEl);
          } else {
            const statsSection = document.querySelector('.stats-section');
            document.body.insertBefore(placeholder, statsSection);
          }
        }
      }

      async function handleDragEnd() {
        const wasDragging = isDragging;
        const didReorder = draggedId !== null && isDragging && dropTargetIndex !== -1;

        if (didReorder) {
          const draggedIndex = orderedIds.indexOf(draggedId);
          if (draggedIndex !== -1 && draggedIndex !== dropTargetIndex) {
            orderedIds.splice(draggedIndex, 1);
            orderedIds.splice(dropTargetIndex, 0, draggedId);
          }
        }

        removeGhost();
        removePlaceholder();
        dropTargetIndex = -1;
        draggedId = null;
        isDragging = false;
        document.body.style.cursor = '';

        if (wasDragging) {
          justFinishedDrag = true;
          setTimeout(() => { justFinishedDrag = false; }, 50);
        }

        if (didReorder) {
          render(true);
          try {
            await invoke('reorder_reminders', { orderedIds });
            await emit('refresh-reminders');
          } catch (e) {
            console.error("Failed to persist order:", e);
          }
        }
      }

      function createCard(reminder, isFocused) {
        const card = document.createElement('div');
        card.className = `reminder-card${isFocused ? ' active' : ''}`;
        card.dataset.id = reminder.id;
        card.dataset.message = reminder.message;

        const urg = urgencyConfig[reminder.urgency] || urgencyConfig.whenever;
        const initialState = isFocused ? 'focused' : 'compact';
        setCardState(card, initialState, reminder.message);

        const urgencyStyle = isFocused ? 'display: block; opacity: 1; transform: translateY(0);' : '';
        const actionsStyle = isFocused ? 'opacity: 1; transform: translateX(0);' : '';

        card.innerHTML = `
          <div class="card-content">
            <div class="card-message">${escapeHtml(reminder.message)}</div>
            <div class="card-urgency ${urg.class}" style="${urgencyStyle}">${urg.label}</div>
          </div>
          <div class="card-actions" style="${actionsStyle}">
            <button class="card-btn complete" title="Complete">&#10003;</button>
            <button class="card-btn dismiss" title="Dismiss">&#10005;</button>
          </div>
        `;

        card.addEventListener('mousedown', (e) => {
          if (e.target.closest('.card-actions')) return;
          handleDragStart(e, reminder.id);
        });

        card.addEventListener('click', (e) => {
          if (e.target.closest('.card-actions')) return;
          if (!isDragging && !justFinishedDrag) {
            handleFocus(reminder.id);
          }
        });

        card.addEventListener('mouseenter', (e) => {
          if (!isDragging && focusedId !== reminder.id) {
            startHoverTimers(card, reminder);
          }
        });

        card.addEventListener('mouseleave', () => {
          clearHoverState(card, reminder.id);
          hideTooltip();
        });

        const completeBtn = card.querySelector('.complete');
        completeBtn.addEventListener('click', () => {
          animateButtonPress(completeBtn);
          handleComplete(reminder.id);
        });

        const dismissBtn = card.querySelector('.dismiss');
        dismissBtn.addEventListener('click', () => {
          animateButtonPress(dismissBtn);
          handleDismiss(reminder.id);
        });

        return card;
      }

      function render(forceRecreate = false) {
        if (focusedId !== null) {
          document.body.classList.add('has-focus');
        } else {
          document.body.classList.remove('has-focus');
        }

        const emptyState = document.body.querySelector('.empty-state');

        if (orderedIds.length === 0) {
          document.body.querySelectorAll('.reminder-card').forEach(el => el.remove());
          if (emptyState) emptyState.style.display = '';
          return;
        }

        if (emptyState) emptyState.style.display = 'none';

        const existingCards = document.body.querySelectorAll('.reminder-card');
        const existingIds = Array.from(existingCards).map(c => parseInt(c.dataset.id));
        const canUpdateInPlace = !forceRecreate &&
          existingIds.length === orderedIds.length &&
          existingIds.every((id, i) => id === orderedIds[i]);

        if (canUpdateInPlace) {
          existingCards.forEach(card => {
            const id = parseInt(card.dataset.id);
            const urgency = card.querySelector('.card-urgency');
            const actions = card.querySelector('.card-actions');
            const message = card.dataset.message || '';
            const wasActive = card.classList.contains('active');
            const shouldBeActive = focusedId === id;

            if (shouldBeActive && !wasActive) {
              card.classList.add('active');
              card.classList.remove('hover-expanded', 'hover-controls');
              clearHoverTimers(id);

              animateFocusIn(card);
              animateCardExpand(card, 'focused', message);
              if (urgency) animateUrgencyIn(urgency);
              if (actions) animateActionsIn(actions);
            } else if (!shouldBeActive && wasActive) {
              card.classList.remove('active');

              animateFocusOut(card);
              animateCardExpand(card, 'compact', message);
              if (urgency) animateUrgencyOut(urgency);
              if (actions) animateActionsOut(actions);
            }
          });
        } else {
          hoverTimers.forEach((_, id) => clearHoverTimers(id));
          document.body.querySelectorAll('.reminder-card').forEach(el => el.remove());

          const statsSection = document.querySelector('.stats-section');
          for (const id of orderedIds) {
            const reminder = reminders.find(r => r.id === id);
            if (reminder) {
              document.body.insertBefore(createCard(reminder, focusedId === id), statsSection);
            }
          }
        }
      }

      function updateStats(today, week) {
        document.getElementById('stats-today').textContent = today;
        document.getElementById('stats-week').textContent = week;
      }

      function updateReminders(newReminders) {
        reminders = newReminders;
        const newIds = newReminders.map(r => r.id);
        const idsChanged = orderedIds.length !== newIds.length ||
          !orderedIds.every((id, i) => id === newIds[i]);
        orderedIds = newIds;

        if (focusedId && !newIds.includes(focusedId)) {
          focusedId = null;
        }

        render(idsChanged);
      }

      async function fetchReminders() {
        try {
          // Get only actual reminders (not backlog)
          const actualReminders = await invoke("get_actual_reminders");
          updateReminders(actualReminders);

          // Get completion stats
          const stats = await invoke("get_completion_stats");
          updateStats(stats[0], stats[1]);
        } catch (e) {
          console.error("Failed to fetch reminders:", e);
        }
      }

      async function setupEventListeners() {
        cleanupFns.push(await listen("refresh-reminders", () => {
          fetchReminders();
        }));

        cleanupFns.push(await listen("focus-reminder", (event) => {
          if (ignoreNextFocusEvent) {
            ignoreNextFocusEvent = false;
            return;
          }
          const newFocusId = event.payload.id;
          if (focusedId !== newFocusId) {
            focusedId = newFocusId;
            render();
          }
        }));
      }

      setupEventListeners();

      document.addEventListener('mousemove', handleDragMove);
      document.addEventListener('mouseup', handleDragEnd);

      // Open list button handler
      document.getElementById('open-list-btn').addEventListener('click', async () => {
        try {
          const { WebviewWindow } = window.__TAURI__.webviewWindow;
          const mainWindow = await WebviewWindow.getByLabel('main');
          if (mainWindow) {
            await mainWindow.show();
            await mainWindow.setFocus();
          }
        } catch (e) {
          console.error('Failed to open main window:', e);
        }
      });

      render();
      fetchReminders();

      pollInterval = setInterval(fetchReminders, 5000);
    </script>
  </body>
</html>
