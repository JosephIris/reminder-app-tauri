<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Reminder Bar</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }
      html, body {
        background: transparent;
        font-family: 'Segoe UI', system-ui, sans-serif;
        overflow: hidden;
        user-select: none;
        height: 100%;
        width: 100%;
        display: flex;
        justify-content: center;
        align-items: center;
      }

      @property --gradient-angle {
        syntax: "<angle>";
        initial-value: 0deg;
        inherits: false;
      }

      .bar-container {
        height: calc(100% - 8px);
        width: calc(100% - 16px);
        margin: 4px 8px;
        background: rgba(13, 13, 13, 0.95);
        backdrop-filter: blur(10px);
        border: 1px solid #333;
        border-radius: 12px;
        display: flex;
        align-items: center;
        justify-content: flex-start;
        padding: 0 12px;
        gap: 8px;
        overflow-x: auto;
        overflow-y: hidden;
      }

      .bar-container::-webkit-scrollbar {
        height: 4px;
      }

      .bar-container::-webkit-scrollbar-track {
        background: transparent;
      }

      .bar-container::-webkit-scrollbar-thumb {
        background: #404040;
        border-radius: 2px;
      }

      /* Default: compact/minimized state - shows message only */
      .reminder-card {
        flex-shrink: 0;
        background: #262626;
        border: 1px solid #404040;
        border-radius: 8px;
        padding: 8px 12px;
        display: flex;
        align-items: center;
        gap: 8px;
        min-width: 100px;
        max-width: 160px;
        height: 40px;
        cursor: grab;
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      }

      .reminder-card:hover {
        background: #333;
        border-color: #505050;
      }

      /* Disable hover effects during drag */
      body.dragging-active .reminder-card:hover {
        background: #262626;
        border-color: #404040;
      }

      body.dragging-active .card-btn:hover {
        background: #1a1a1a;
        color: #a1a1aa;
      }

      .reminder-card.dragging {
        opacity: 0.8;
        cursor: grabbing;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
      }

      .focus-wrapper {
        position: relative;
        padding: 2px;
        border-radius: 10px;
        flex-shrink: 0;
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      }

      @property --glow-opacity {
        syntax: "<number>";
        initial-value: 0.4;
        inherits: false;
      }

      /* Hover expanded state (after 2s) - show full text */
      .focus-wrapper.hover-expanded .reminder-card {
        min-width: 200px;
        max-width: 280px;
        padding: 8px 12px;
        gap: 12px;
      }

      .focus-wrapper.hover-expanded .card-message {
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }

      /* Hover with controls state (after 4s) - show actions */
      .focus-wrapper.hover-controls .card-actions {
        opacity: 1;
        pointer-events: auto;
      }

      /* Focused state (click) - full expansion with glow */
      .focus-wrapper.active {
        background: conic-gradient(
          from var(--gradient-angle),
          #8b5cf6,
          #6366f1,
          #3b82f6,
          #06b6d4,
          #8b5cf6
        );
        animation: gradient-rotate 2s linear infinite, glow-pulse 2s ease-in-out infinite;
        box-shadow:
          0 0 20px rgba(139, 92, 246, var(--glow-opacity)),
          0 0 40px rgba(99, 102, 241, calc(var(--glow-opacity) * 0.5));
      }

      .focus-wrapper.active .reminder-card {
        border-color: transparent;
        overflow: hidden;
        position: relative;
        min-width: 320px;
        max-width: 380px;
        height: 48px;
        padding: 10px 14px;
      }

      .focus-wrapper.active .card-message {
        font-size: 14px;
        white-space: normal;
        overflow: visible;
        text-overflow: clip;
      }

      .focus-wrapper.active .card-actions {
        opacity: 1;
        pointer-events: auto;
      }

      .focus-wrapper.active .card-btn {
        width: 32px;
        height: 32px;
        font-size: 13px;
      }

      .focus-wrapper.active .card-btn.snooze-inline {
        width: 28px;
        font-size: 11px;
      }

      /* Minimize other cards when one is focused */
      .bar-container.has-focus .focus-wrapper:not(.active) .reminder-card {
        min-width: 80px;
        max-width: 100px;
        padding: 8px 10px;
        gap: 8px;
      }

      .bar-container.has-focus .focus-wrapper:not(.active) .card-message {
        font-size: 11px;
      }

      .bar-container.has-focus .focus-wrapper:not(.active) .card-actions {
        opacity: 0;
        pointer-events: none;
        width: 0;
        overflow: hidden;
      }

      .bar-container.has-focus .focus-wrapper:not(.active) .card-time {
        display: none;
      }

      /* Shimmer effect - diagonal sweep */
      .focus-wrapper.active .reminder-card::before {
        content: '';
        position: absolute;
        top: -50%;
        left: -100%;
        width: 80%;
        height: 200%;
        background: linear-gradient(
          120deg,
          transparent 20%,
          rgba(139, 92, 246, 0.08) 30%,
          rgba(99, 102, 241, 0.15) 40%,
          rgba(59, 130, 246, 0.2) 50%,
          rgba(99, 102, 241, 0.15) 60%,
          rgba(139, 92, 246, 0.08) 70%,
          transparent 80%
        );
        animation: shimmer 5s ease-in-out infinite;
        pointer-events: none;
        transform: skewX(-20deg);
      }

      @keyframes gradient-rotate {
        to {
          --gradient-angle: 360deg;
        }
      }

      @keyframes glow-pulse {
        0%, 100% {
          --glow-opacity: 0.3;
        }
        50% {
          --glow-opacity: 0.6;
        }
      }

      @keyframes shimmer {
        0% {
          left: -100%;
        }
        50%, 100% {
          left: 200%;
        }
      }

      .card-content {
        flex: 1;
        min-width: 0;
        display: flex;
        flex-direction: column;
        gap: 2px;
      }

      .card-message {
        color: #fafafa;
        font-size: 12px;
        font-weight: 500;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        transition: font-size 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      }

      /* Hide time by default - only show message in compact mode */
      .card-time {
        color: #a1a1aa;
        font-size: 10px;
        transition: opacity 0.2s ease;
        display: none;
      }

      /* Show time when expanded or focused */
      .focus-wrapper.hover-expanded .card-time,
      .focus-wrapper.hover-controls .card-time,
      .focus-wrapper.active .card-time {
        display: block;
      }

      .card-actions {
        display: flex;
        gap: 4px;
        transition: opacity 0.2s ease, transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        /* Hidden by default */
        opacity: 0;
        pointer-events: none;
      }

      .card-btn {
        border: none;
        background: #1a1a1a;
        color: #a1a1aa;
        width: 28px;
        height: 28px;
        border-radius: 6px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 12px;
        transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
      }

      .card-btn:hover {
        background: #333;
        color: #fafafa;
      }

      .card-btn.complete:hover {
        background: #22c55e;
        color: white;
      }

      .card-btn.dismiss:hover {
        background: #ef4444;
        color: white;
      }

      .card-btn.snooze-inline {
        font-size: 10px;
        font-weight: 600;
        width: 24px;
      }

      .card-btn.snooze-inline:hover {
        background: #6366f1;
        color: white;
      }

      /* Drag ghost - follows cursor */
      .drag-ghost {
        position: fixed;
        pointer-events: none;
        z-index: 10000;
        opacity: 0.9;
        transform: rotate(2deg);
        box-shadow: 0 8px 24px rgba(0, 0, 0, 0.4);
      }

      /* Original card becomes semi-transparent during drag */
      .focus-wrapper.being-dragged .reminder-card {
        opacity: 0.3;
      }

      /* Placeholder shows drop position */
      .drag-placeholder {
        flex-shrink: 0;
        width: 100px;
        height: 40px;
        background: rgba(99, 102, 241, 0.2);
        border: 2px dashed #6366f1;
        border-radius: 8px;
        margin: 0 6px;
      }

      .empty-state {
        color: #71717a;
        font-size: 13px;
        padding: 0 8px;
      }

      /* Tooltip styles */
      .tooltip {
        position: fixed;
        background: #1a1a1a;
        border: 1px solid #404040;
        border-radius: 6px;
        padding: 6px 10px;
        z-index: 10000;
        pointer-events: none;
        max-width: 400px;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.4);
        display: flex;
        align-items: center;
        gap: 12px;
      }

      .tooltip-message {
        color: #fafafa;
        font-size: 12px;
        font-weight: 500;
        word-wrap: break-word;
      }

      .tooltip-time {
        color: #71717a;
        font-size: 10px;
        white-space: nowrap;
      }
    </style>
  </head>
  <body>
    <div class="bar-container" id="bar-container">
      <div class="empty-state">No reminders due</div>
    </div>

    <script type="module">
      const { invoke } = window.__TAURI__.core;
      const { listen, emit } = window.__TAURI__.event;

      let reminders = [];
      let orderedIds = [];
      let focusedId = null;
      let ignoreNextFocusEvent = false;
      let draggedId = null;
      let dragStartX = 0;
      let dragOffsetX = 0;
      let isDragging = false;
      let justFinishedDrag = false;
      let tooltipEl = null;
      let ghostEl = null;
      let placeholderEl = null;
      let dropTargetIndex = -1;

      // Hover state tracking per card
      const hoverTimers = new Map(); // id -> { expandTimer, controlsTimer }

      console.log("[BAR] Script loaded");

      // Create tooltip element
      function createTooltip() {
        if (!tooltipEl) {
          tooltipEl = document.createElement('div');
          tooltipEl.className = 'tooltip';
          tooltipEl.style.display = 'none';
          document.body.appendChild(tooltipEl);
        }
      }
      createTooltip();

      function showTooltip(reminder, x, y) {
        if (!tooltipEl || isDragging) return;
        const createdDate = new Date(reminder.created_at);
        const createdStr = createdDate.toLocaleString('en-US', {
          month: 'short',
          day: 'numeric',
          hour: 'numeric',
          minute: '2-digit',
          hour12: true
        });
        tooltipEl.innerHTML = `
          <span class="tooltip-message">${reminder.message}</span>
          <span class="tooltip-time">Created: ${createdStr}</span>
        `;
        const tooltipWidth = 420;
        tooltipEl.style.left = Math.min(Math.max(x - 100, 8), window.innerWidth - tooltipWidth) + 'px';
        tooltipEl.style.top = '8px';
        tooltipEl.style.bottom = 'auto';
        tooltipEl.style.display = 'flex';
      }

      function hideTooltip() {
        if (tooltipEl) {
          tooltipEl.style.display = 'none';
        }
      }

      function formatTime(isoString) {
        const date = new Date(isoString);
        return date.toLocaleTimeString('en-US', {
          hour: 'numeric',
          minute: '2-digit',
          hour12: true
        });
      }

      function truncate(str, maxLen) {
        return str.length > maxLen ? str.substring(0, maxLen - 1) + '...' : str;
      }

      async function handleComplete(id) {
        await invoke("complete_reminder", { id });
        await emit("refresh-reminders");
      }

      async function handleSnooze(id, minutes) {
        await invoke("snooze_reminder", { id, minutes });
        await emit("refresh-reminders");
      }

      async function handleDismiss(id) {
        await invoke("delete_reminder", { id });
        await emit("refresh-reminders");
      }

      async function handleFocus(id) {
        focusedId = focusedId === id ? null : id;
        render();
        ignoreNextFocusEvent = true;
        await emit("focus-reminder", { id: focusedId });
      }

      // Hover state management
      function startHoverTimers(wrapper, reminder) {
        const id = reminder.id;
        clearHoverTimers(id);

        const timers = {
          expandTimer: setTimeout(() => {
            if (!isDragging && focusedId !== id) {
              wrapper.classList.add('hover-expanded');
            }
          }, 2000), // 2s for expand
          controlsTimer: setTimeout(() => {
            if (!isDragging && focusedId !== id) {
              wrapper.classList.add('hover-controls');
            }
          }, 4000) // 4s for controls
        };

        hoverTimers.set(id, timers);
      }

      function clearHoverTimers(id) {
        const timers = hoverTimers.get(id);
        if (timers) {
          clearTimeout(timers.expandTimer);
          clearTimeout(timers.controlsTimer);
          hoverTimers.delete(id);
        }
      }

      function clearHoverState(wrapper, id) {
        clearHoverTimers(id);
        wrapper.classList.remove('hover-expanded', 'hover-controls');
      }

      function handleDragStart(e, id) {
        draggedId = id;
        dragStartX = e.clientX;
        isDragging = false;
        hideTooltip();

        const wrapper = e.target.closest('.focus-wrapper');
        const rect = wrapper.getBoundingClientRect();
        dragOffsetX = e.clientX - rect.left;

        document.body.style.cursor = 'grabbing';
      }

      function createGhost(wrapper) {
        const card = wrapper.querySelector('.reminder-card');
        ghostEl = card.cloneNode(true);
        ghostEl.className = 'reminder-card drag-ghost';
        document.body.appendChild(ghostEl);
        document.body.classList.add('dragging-active');
        wrapper.classList.add('being-dragged');
      }

      function removeGhost() {
        if (ghostEl) {
          ghostEl.remove();
          ghostEl = null;
        }
        document.body.classList.remove('dragging-active');
        const dragged = document.querySelector('.being-dragged');
        if (dragged) {
          dragged.classList.remove('being-dragged');
        }
      }

      function createPlaceholder() {
        if (!placeholderEl) {
          placeholderEl = document.createElement('div');
          placeholderEl.className = 'drag-placeholder';
        }
        return placeholderEl;
      }

      function removePlaceholder() {
        if (placeholderEl && placeholderEl.parentNode) {
          placeholderEl.remove();
        }
      }

      function handleDragMove(e) {
        if (draggedId === null) return;

        if (!isDragging && Math.abs(e.clientX - dragStartX) > 5) {
          isDragging = true;
          const wrapper = document.querySelector(`.focus-wrapper[data-id="${draggedId}"]`);
          if (wrapper) {
            createGhost(wrapper);
          }
        }

        if (!isDragging) return;

        if (ghostEl) {
          ghostEl.style.left = (e.clientX - dragOffsetX) + 'px';
          ghostEl.style.top = (e.clientY - 20) + 'px';
        }

        const container = document.getElementById('bar-container');
        const wrappers = Array.from(container.querySelectorAll('.focus-wrapper:not(.being-dragged)'));

        let newDropIndex = orderedIds.length;

        for (let i = 0; i < wrappers.length; i++) {
          const wrapper = wrappers[i];
          const rect = wrapper.getBoundingClientRect();
          const midX = rect.left + rect.width / 2;

          if (e.clientX < midX) {
            newDropIndex = orderedIds.indexOf(parseInt(wrapper.dataset.id));
            break;
          }
        }

        const draggedIndex = orderedIds.indexOf(draggedId);
        if (newDropIndex > draggedIndex) {
          newDropIndex--;
        }

        if (newDropIndex !== dropTargetIndex) {
          dropTargetIndex = newDropIndex;
          removePlaceholder();

          const placeholder = createPlaceholder();
          const allWrappers = Array.from(container.querySelectorAll('.focus-wrapper'));

          let insertBeforeEl = null;
          let count = 0;
          for (const w of allWrappers) {
            if (w.classList.contains('being-dragged')) continue;
            if (count === dropTargetIndex) {
              insertBeforeEl = w;
              break;
            }
            count++;
          }

          if (insertBeforeEl) {
            container.insertBefore(placeholder, insertBeforeEl);
          } else {
            container.appendChild(placeholder);
          }
        }
      }

      async function handleDragEnd() {
        const wasDragging = isDragging;
        const didReorder = draggedId !== null && isDragging && dropTargetIndex !== -1;

        if (didReorder) {
          const draggedIndex = orderedIds.indexOf(draggedId);
          if (draggedIndex !== -1 && draggedIndex !== dropTargetIndex) {
            orderedIds.splice(draggedIndex, 1);
            orderedIds.splice(dropTargetIndex, 0, draggedId);
          }
        }

        removeGhost();
        removePlaceholder();
        dropTargetIndex = -1;
        draggedId = null;
        isDragging = false;
        document.body.style.cursor = '';

        if (wasDragging) {
          justFinishedDrag = true;
          setTimeout(() => { justFinishedDrag = false; }, 50);
        }

        if (didReorder) {
          render(true);

          try {
            await invoke('reorder_reminders', { orderedIds });
            await emit('refresh-reminders');
          } catch (e) {
            console.error("Failed to persist order:", e);
          }
        }
      }

      function createCard(reminder, isFocused) {
        const wrapper = document.createElement('div');
        wrapper.className = `focus-wrapper${isFocused ? ' active' : ''}`;
        wrapper.dataset.id = reminder.id;

        const card = document.createElement('div');
        card.className = 'reminder-card';

        card.innerHTML = `
          <div class="card-content">
            <div class="card-message">${truncate(reminder.message, 30)}</div>
            <div class="card-time">${formatTime(reminder.due_time)}</div>
          </div>
          <div class="card-actions">
            <button class="card-btn snooze-inline" data-minutes="15" title="Snooze 15 min">15</button>
            <button class="card-btn snooze-inline" data-minutes="60" title="Snooze 1 hour">60</button>
            <button class="card-btn complete" title="Complete">&#10003;</button>
            <button class="card-btn dismiss" title="Dismiss">&#10005;</button>
          </div>
        `;

        // Drag start
        card.addEventListener('mousedown', (e) => {
          if (e.target.closest('.card-actions')) return;
          handleDragStart(e, reminder.id);
        });

        // Click to focus
        card.addEventListener('click', (e) => {
          if (e.target.closest('.card-actions')) return;
          if (!isDragging && !justFinishedDrag) {
            handleFocus(reminder.id);
          }
        });

        // Hover state management - start timers on enter
        wrapper.addEventListener('mouseenter', (e) => {
          if (!isDragging && focusedId !== reminder.id) {
            startHoverTimers(wrapper, reminder);
          }
        });

        // Clear hover state on leave
        wrapper.addEventListener('mouseleave', () => {
          clearHoverState(wrapper, reminder.id);
          hideTooltip();
        });

        // Action buttons
        card.querySelector('.complete').addEventListener('click', () => handleComplete(reminder.id));
        card.querySelector('.dismiss').addEventListener('click', () => handleDismiss(reminder.id));

        card.querySelectorAll('.snooze-inline').forEach(btn => {
          btn.addEventListener('click', () => {
            handleSnooze(reminder.id, parseInt(btn.dataset.minutes));
          });
        });

        wrapper.appendChild(card);
        return wrapper;
      }

      function render(forceRecreate = false) {
        const container = document.getElementById('bar-container');

        if (focusedId !== null) {
          container.classList.add('has-focus');
        } else {
          container.classList.remove('has-focus');
        }

        if (orderedIds.length === 0) {
          container.innerHTML = '<div class="empty-state">No reminders due</div>';
          return;
        }

        const existingWrappers = container.querySelectorAll('.focus-wrapper');
        const existingIds = Array.from(existingWrappers).map(w => parseInt(w.dataset.id));
        const canUpdateInPlace = !forceRecreate &&
          existingIds.length === orderedIds.length &&
          existingIds.every((id, i) => id === orderedIds[i]);

        if (canUpdateInPlace) {
          existingWrappers.forEach(wrapper => {
            const id = parseInt(wrapper.dataset.id);
            if (focusedId === id) {
              wrapper.classList.add('active');
              // Clear hover states when focused
              wrapper.classList.remove('hover-expanded', 'hover-controls');
              clearHoverTimers(id);
            } else {
              wrapper.classList.remove('active');
            }
          });
        } else {
          // Clear all hover timers before rebuild
          hoverTimers.forEach((_, id) => clearHoverTimers(id));

          container.innerHTML = '';
          for (const id of orderedIds) {
            const reminder = reminders.find(r => r.id === id);
            if (reminder) {
              container.appendChild(createCard(reminder, focusedId === id));
            }
          }
        }
      }

      function updateReminders(newReminders) {
        reminders = newReminders;

        // Use server's sort order - reminders come sorted by sort_order from backend
        // DON'T reverse - left of bar = top of list (lowest sort_order)
        const newIds = newReminders.map(r => r.id);
        const idsChanged = orderedIds.length !== newIds.length ||
          !orderedIds.every((id, i) => id === newIds[i]);
        orderedIds = newIds;

        if (focusedId && !newIds.includes(focusedId)) {
          focusedId = null;
        }

        render(idsChanged);
      }

      function filterDueReminders(allReminders) {
        const now = new Date();
        return allReminders.filter(r => {
          if (r.is_completed) return false;
          const dueTime = new Date(r.due_time);
          return dueTime <= now;
        });
      }

      async function fetchReminders() {
        try {
          const allPending = await invoke("get_pending_reminders");
          const dueReminders = filterDueReminders(allPending);
          updateReminders(dueReminders);
        } catch (e) {
          console.error("Failed to fetch reminders:", e);
        }
      }

      listen("update-reminders", (event) => {
        updateReminders(event.payload.reminders);
      });

      listen("refresh-reminders", () => {
        fetchReminders();
      });

      listen("focus-reminder", (event) => {
        if (ignoreNextFocusEvent) {
          ignoreNextFocusEvent = false;
          return;
        }
        const newFocusId = event.payload.id;
        if (focusedId !== newFocusId) {
          focusedId = newFocusId;
          render();
        }
      });

      document.addEventListener('mousemove', handleDragMove);
      document.addEventListener('mouseup', handleDragEnd);

      render();
      fetchReminders();

      setInterval(fetchReminders, 1000);

      // Reposition on visibility restore (monitor wake)
      let wasHidden = false;
      let lastRepositionTime = 0;

      document.addEventListener('visibilitychange', async () => {
        if (document.visibilityState === 'hidden') {
          wasHidden = true;
        } else if (document.visibilityState === 'visible' && wasHidden) {
          wasHidden = false;
          const now = Date.now();
          if (now - lastRepositionTime > 2000) {
            lastRepositionTime = now;
            try {
              await invoke('reposition_reminder_bar');
            } catch (e) {
              console.error('Reposition failed:', e);
            }
          }
        }
      });
    </script>
  </body>
</html>
