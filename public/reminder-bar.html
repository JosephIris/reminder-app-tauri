<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Reminder Bar</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }
      html, body {
        background: transparent;
        font-family: 'Segoe UI', system-ui, sans-serif;
        overflow: hidden;
        user-select: none;
        height: 100%;
        width: 100%;
        display: flex;
        justify-content: center;
        align-items: center;
      }

      @property --gradient-angle {
        syntax: "<angle>";
        initial-value: 0deg;
        inherits: false;
      }

      .bar-container {
        height: calc(100% - 8px);
        width: calc(100% - 16px);
        margin: 4px 8px;
        background: rgba(13, 13, 13, 0.95);
        backdrop-filter: blur(10px);
        border: 1px solid #333;
        border-radius: 12px;
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 0 12px;
        gap: 8px;
        overflow-x: auto;
        overflow-y: hidden;
      }

      .bar-container::-webkit-scrollbar {
        height: 4px;
      }

      .bar-container::-webkit-scrollbar-track {
        background: transparent;
      }

      .bar-container::-webkit-scrollbar-thumb {
        background: #404040;
        border-radius: 2px;
      }

      .reminder-card {
        flex-shrink: 0;
        background: #262626;
        border: 1px solid #404040;
        border-radius: 8px;
        padding: 8px 12px;
        display: flex;
        align-items: center;
        gap: 12px;
        min-width: 200px;
        max-width: 280px;
        height: 40px;
        cursor: grab;
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      }

      /* Minimized cards when another is focused */
      .bar-container.has-focus .focus-wrapper:not(.active) .reminder-card {
        min-width: 100px;
        max-width: 100px;
        padding: 8px 10px;
        gap: 8px;
      }

      
      .bar-container.has-focus .focus-wrapper:not(.active) .card-message {
        font-size: 11px;
      }

      .reminder-card:hover {
        background: #333;
        border-color: #505050;
      }

      /* Disable hover effects during drag */
      body.dragging-active .reminder-card:hover {
        background: #262626;
        border-color: #404040;
      }

      body.dragging-active .card-btn:hover {
        background: #1a1a1a;
        color: #a1a1aa;
      }

      .reminder-card.dragging {
        opacity: 0.8;
        cursor: grabbing;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
      }

      .focus-wrapper {
        position: relative;
        padding: 2px;
        border-radius: 10px;
        flex-shrink: 0;
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      }

      @property --glow-opacity {
        syntax: "<number>";
        initial-value: 0.4;
        inherits: false;
      }

      .focus-wrapper.active {
        background: conic-gradient(
          from var(--gradient-angle),
          #8b5cf6,
          #6366f1,
          #3b82f6,
          #06b6d4,
          #8b5cf6
        );
        animation: gradient-rotate 2s linear infinite, glow-pulse 2s ease-in-out infinite;
        box-shadow:
          0 0 20px rgba(139, 92, 246, var(--glow-opacity)),
          0 0 40px rgba(99, 102, 241, calc(var(--glow-opacity) * 0.5));
      }

      .focus-wrapper.active .reminder-card {
        border-color: transparent;
        overflow: hidden;
        position: relative;
        min-width: 320px;
        max-width: 380px;
        height: 48px;
        padding: 10px 14px;
      }

      .focus-wrapper.active .card-message {
        font-size: 14px;
      }

      .focus-wrapper.active .card-btn {
        width: 32px;
        height: 32px;
        font-size: 13px;
      }

      .focus-wrapper.active .card-btn.snooze-inline {
        width: 28px;
        font-size: 11px;
      }

      /* Shimmer effect - diagonal sweep */
      .focus-wrapper.active .reminder-card::before {
        content: '';
        position: absolute;
        top: -50%;
        left: -100%;
        width: 80%;
        height: 200%;
        background: linear-gradient(
          120deg,
          transparent 20%,
          rgba(139, 92, 246, 0.08) 30%,
          rgba(99, 102, 241, 0.15) 40%,
          rgba(59, 130, 246, 0.2) 50%,
          rgba(99, 102, 241, 0.15) 60%,
          rgba(139, 92, 246, 0.08) 70%,
          transparent 80%
        );
        animation: shimmer 5s ease-in-out infinite;
        pointer-events: none;
        transform: skewX(-20deg);
      }

      @keyframes gradient-rotate {
        to {
          --gradient-angle: 360deg;
        }
      }

      @keyframes glow-pulse {
        0%, 100% {
          --glow-opacity: 0.3;
        }
        50% {
          --glow-opacity: 0.6;
        }
      }

      @keyframes shimmer {
        0% {
          left: -100%;
        }
        50%, 100% {
          left: 200%;
        }
      }

      .card-content {
        flex: 1;
        min-width: 0;
        display: flex;
        flex-direction: column;
        gap: 2px;
      }

      .card-message {
        color: #fafafa;
        font-size: 13px;
        font-weight: 500;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        transition: font-size 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      }

      .card-time {
        color: #a1a1aa;
        font-size: 11px;
        transition: opacity 0.2s ease;
      }

      .card-actions {
        display: flex;
        gap: 4px;
        transition: opacity 0.2s ease, transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        /* Hidden by default - shown on hover or when focused */
        opacity: 0;
        pointer-events: none;
      }

      /* Show actions on hover */
      .reminder-card:hover .card-actions {
        opacity: 1;
        pointer-events: auto;
      }

      /* Always show actions for focused card */
      .focus-wrapper.active .card-actions {
        opacity: 1;
        pointer-events: auto;
      }

      /* Hide actions completely for minimized cards when another is focused */
      .bar-container.has-focus .focus-wrapper:not(.active) .card-actions {
        opacity: 0;
        transform: scale(0.8);
        pointer-events: none;
        width: 0;
        overflow: hidden;
      }

      .bar-container.has-focus .focus-wrapper:not(.active) .card-time {
        opacity: 0;
        height: 0;
        margin: 0;
      }

      .card-btn {
        border: none;
        background: #1a1a1a;
        color: #a1a1aa;
        width: 28px;
        height: 28px;
        border-radius: 6px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 12px;
        transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
      }

      .card-btn:hover {
        background: #333;
        color: #fafafa;
      }

      .card-btn.complete:hover {
        background: #22c55e;
        color: white;
      }

      .card-btn.dismiss:hover {
        background: #ef4444;
        color: white;
      }

      .card-btn.snooze-inline {
        font-size: 10px;
        font-weight: 600;
        width: 24px;
      }

      .card-btn.snooze-inline:hover {
        background: #6366f1;
        color: white;
      }

      /* Drag ghost - follows cursor */
      .drag-ghost {
        position: fixed;
        pointer-events: none;
        z-index: 10000;
        opacity: 0.9;
        transform: rotate(2deg);
        box-shadow: 0 8px 24px rgba(0, 0, 0, 0.4);
      }

      /* Original card becomes semi-transparent during drag */
      .focus-wrapper.being-dragged .reminder-card {
        opacity: 0.3;
      }

      /* Placeholder shows drop position */
      .drag-placeholder {
        flex-shrink: 0;
        width: 200px;
        height: 40px;
        background: rgba(99, 102, 241, 0.2);
        border: 2px dashed #6366f1;
        border-radius: 8px;
        margin: 0 6px;
      }

      .empty-state {
        color: #71717a;
        font-size: 13px;
        padding: 0 8px;
      }

      /* Debug panel */
      .debug-panel {
        position: fixed;
        top: 4px;
        right: 4px;
        background: rgba(0, 0, 0, 0.95);
        border: 1px solid #404040;
        border-radius: 6px;
        padding: 8px;
        font-size: 10px;
        font-family: 'Consolas', 'Monaco', monospace;
        color: #a1a1aa;
        width: 380px;
        max-height: 250px;
        overflow-y: auto;
        z-index: 9999;
        display: none;
      }

      .debug-panel.visible {
        display: block;
      }

      .debug-panel .debug-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 6px;
        padding-bottom: 4px;
        border-bottom: 1px solid #333;
      }

      .debug-panel .debug-title {
        color: #fafafa;
        font-weight: 600;
        font-size: 11px;
      }

      .debug-panel .debug-btns {
        display: flex;
        gap: 4px;
      }

      .debug-panel .debug-btn {
        background: #333;
        border: none;
        color: #a1a1aa;
        padding: 3px 8px;
        border-radius: 3px;
        cursor: pointer;
        font-size: 9px;
      }

      .debug-panel .debug-btn:hover {
        background: #404040;
        color: #fafafa;
      }

      .debug-panel .debug-btn.copy-btn:hover {
        background: #6366f1;
      }

      .debug-panel .debug-log {
        white-space: pre-wrap;
        word-break: break-all;
        line-height: 1.4;
      }

      .debug-panel .log-entry {
        margin: 2px 0;
        padding: 2px 0;
        border-bottom: 1px solid #222;
      }

      .debug-panel .log-time {
        color: #6366f1;
        margin-right: 6px;
      }

      .debug-panel .log-info {
        color: #22c55e;
      }

      .debug-panel .log-warn {
        color: #f59e0b;
      }

      .debug-panel .log-error {
        color: #ef4444;
      }

      .debug-panel .log-position {
        color: #06b6d4;
      }

      .debug-toggle {
        position: fixed;
        top: 4px;
        right: 4px;
        background: rgba(0, 0, 0, 0.7);
        border: 1px solid #333;
        color: #6366f1;
        width: 20px;
        height: 20px;
        border-radius: 4px;
        cursor: pointer;
        font-size: 12px;
        z-index: 9998;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .debug-toggle:hover {
        background: #333;
        color: #fafafa;
      }

      /* Tooltip styles - compact to fit in bar */
      .tooltip {
        position: fixed;
        background: #1a1a1a;
        border: 1px solid #404040;
        border-radius: 6px;
        padding: 6px 10px;
        z-index: 10000;
        pointer-events: none;
        max-width: 400px;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.4);
        display: flex;
        align-items: center;
        gap: 12px;
      }

      .tooltip-message {
        color: #fafafa;
        font-size: 12px;
        font-weight: 500;
        word-wrap: break-word;
      }

      .tooltip-time {
        color: #71717a;
        font-size: 10px;
        white-space: nowrap;
      }
    </style>
  </head>
  <body>
    <button class="debug-toggle" id="debug-toggle" title="Toggle Debug Panel">ðŸ”§</button>
    <div class="debug-panel" id="debug-panel">
      <div class="debug-header">
        <span class="debug-title">Debug Log</span>
        <div class="debug-btns">
          <button class="debug-btn" id="debug-clear">Clear</button>
          <button class="debug-btn copy-btn" id="debug-copy">ðŸ“‹ Copy</button>
        </div>
      </div>
      <div class="debug-log" id="debug-log"></div>
    </div>
    <div class="bar-container" id="bar-container">
      <div class="empty-state">No reminders due</div>
    </div>

    <script type="module">
      const { invoke } = window.__TAURI__.core;
      const { listen, emit } = window.__TAURI__.event;

      // ========== DEBUG LOGGING SYSTEM ==========
      const debugLog = [];
      const MAX_LOG_ENTRIES = 100;
      let debugPanelVisible = false;
      let lastWindowPosition = null;  // Track window position to detect actual changes

      function formatLogTime() {
        const now = new Date();
        return now.toLocaleTimeString('en-US', { hour12: false }) + '.' + String(now.getMilliseconds()).padStart(3, '0');
      }

      function log(message, type = 'info') {
        const entry = { time: formatLogTime(), message, type };
        debugLog.push(entry);
        if (debugLog.length > MAX_LOG_ENTRIES) {
          debugLog.shift();
        }
        updateDebugPanel();

        // Also log to console for dev tools
        const prefix = `[BAR ${entry.time}]`;
        if (type === 'error') console.error(prefix, message);
        else if (type === 'warn') console.warn(prefix, message);
        else console.log(prefix, message);
      }

      function logPosition(label, data) {
        log(`${label}: ${JSON.stringify(data)}`, 'position');
      }

      function updateDebugPanel() {
        const logEl = document.getElementById('debug-log');
        if (!logEl) return;

        logEl.innerHTML = debugLog.map(entry => {
          const typeClass = entry.type === 'error' ? 'log-error' :
                           entry.type === 'warn' ? 'log-warn' :
                           entry.type === 'position' ? 'log-position' :
                           'log-info';
          return `<div class="log-entry"><span class="log-time">${entry.time}</span><span class="${typeClass}">${entry.message}</span></div>`;
        }).join('');

        // Auto-scroll to bottom
        logEl.scrollTop = logEl.scrollHeight;
      }

      function getLogText() {
        return debugLog.map(e => `[${e.time}] [${e.type.toUpperCase()}] ${e.message}`).join('\n');
      }

      // Setup debug panel controls
      document.getElementById('debug-toggle').addEventListener('click', () => {
        debugPanelVisible = !debugPanelVisible;
        document.getElementById('debug-panel').classList.toggle('visible', debugPanelVisible);
      });

      document.getElementById('debug-clear').addEventListener('click', () => {
        debugLog.length = 0;
        updateDebugPanel();
        log('Log cleared');
      });

      document.getElementById('debug-copy').addEventListener('click', async () => {
        const text = getLogText();
        try {
          await navigator.clipboard.writeText(text);
          log('Log copied to clipboard!', 'info');
        } catch (e) {
          log('Failed to copy: ' + e.message, 'error');
        }
      });

      // Log initial window info
      function logWindowInfo() {
        const info = {
          innerWidth: window.innerWidth,
          innerHeight: window.innerHeight,
          screenX: window.screenX,
          screenY: window.screenY,
          devicePixelRatio: window.devicePixelRatio
        };
        logPosition('Window', info);
        return info;
      }

      // ========== END DEBUG LOGGING ==========

      let reminders = [];
      let orderedIds = [];
      let focusedId = null;
      let ignoreNextFocusEvent = false;  // Flag to ignore our own focus events
      let draggedId = null;
      let dragStartX = 0;
      let dragOffsetX = 0;
      let isDragging = false;
      let justFinishedDrag = false;
      let tooltipEl = null;
      let tooltipTimeout = null;
      let ghostEl = null;
      let placeholderEl = null;
      let dropTargetIndex = -1;

      log("Reminder bar script loaded");

      // Create tooltip element
      function createTooltip() {
        if (!tooltipEl) {
          tooltipEl = document.createElement('div');
          tooltipEl.className = 'tooltip';
          tooltipEl.style.display = 'none';
          document.body.appendChild(tooltipEl);
        }
      }
      createTooltip();

      function showTooltip(reminder, x, y) {
        if (!tooltipEl || isDragging) return;
        const createdDate = new Date(reminder.created_at);
        const createdStr = createdDate.toLocaleString('en-US', {
          month: 'short',
          day: 'numeric',
          hour: 'numeric',
          minute: '2-digit',
          hour12: true
        });
        tooltipEl.innerHTML = `
          <span class="tooltip-message">${reminder.message}</span>
          <span class="tooltip-time">Created: ${createdStr}</span>
        `;
        // Position tooltip inside the bar window
        const tooltipWidth = 420;  // approximate
        tooltipEl.style.left = Math.min(Math.max(x - 100, 8), window.innerWidth - tooltipWidth) + 'px';
        tooltipEl.style.top = '8px';
        tooltipEl.style.bottom = 'auto';
        tooltipEl.style.display = 'flex';
      }

      function hideTooltip() {
        if (tooltipEl) {
          tooltipEl.style.display = 'none';
        }
        if (tooltipTimeout) {
          clearTimeout(tooltipTimeout);
          tooltipTimeout = null;
        }
      }

      function formatTime(isoString) {
        const date = new Date(isoString);
        return date.toLocaleTimeString('en-US', {
          hour: 'numeric',
          minute: '2-digit',
          hour12: true
        });
      }

      function truncate(str, maxLen) {
        return str.length > maxLen ? str.substring(0, maxLen - 1) + '...' : str;
      }

      async function handleComplete(id) {
        await invoke("complete_reminder", { id });
        // Emit to all windows - main will pick it up
        await emit("refresh-reminders");
      }

      async function handleSnooze(id, minutes) {
        await invoke("snooze_reminder", { id, minutes });
        await emit("refresh-reminders");
      }

      async function handleDismiss(id) {
        // Delete from storage
        await invoke("delete_reminder", { id });
        await emit("refresh-reminders");
      }

      async function handleFocus(id) {
        focusedId = focusedId === id ? null : id;
        render();
        // Mark that we're emitting, so we ignore our own event
        ignoreNextFocusEvent = true;
        // Emit focus event to main window
        await emit("focus-reminder", { id: focusedId });
      }

      function handleDragStart(e, id) {
        draggedId = id;
        dragStartX = e.clientX;
        isDragging = false;  // Not dragging until we move enough
        hideTooltip();

        const wrapper = e.target.closest('.focus-wrapper');
        const rect = wrapper.getBoundingClientRect();
        dragOffsetX = e.clientX - rect.left;

        document.body.style.cursor = 'grabbing';
      }

      function createGhost(wrapper) {
        const card = wrapper.querySelector('.reminder-card');
        ghostEl = card.cloneNode(true);
        ghostEl.className = 'reminder-card drag-ghost';
        document.body.appendChild(ghostEl);
        document.body.classList.add('dragging-active');
        wrapper.classList.add('being-dragged');
      }

      function removeGhost() {
        if (ghostEl) {
          ghostEl.remove();
          ghostEl = null;
        }
        document.body.classList.remove('dragging-active');
        const dragged = document.querySelector('.being-dragged');
        if (dragged) {
          dragged.classList.remove('being-dragged');
        }
      }

      function createPlaceholder() {
        if (!placeholderEl) {
          placeholderEl = document.createElement('div');
          placeholderEl.className = 'drag-placeholder';
        }
        return placeholderEl;
      }

      function removePlaceholder() {
        if (placeholderEl && placeholderEl.parentNode) {
          placeholderEl.remove();
        }
      }

      function handleDragMove(e) {
        if (draggedId === null) return;

        // Only start actual dragging after moving 5px
        if (!isDragging && Math.abs(e.clientX - dragStartX) > 5) {
          isDragging = true;
          // Create ghost when drag actually starts
          const wrapper = document.querySelector(`.focus-wrapper[data-id="${draggedId}"]`);
          if (wrapper) {
            createGhost(wrapper);
          }
        }

        if (!isDragging) return;

        // Move ghost to follow cursor
        if (ghostEl) {
          ghostEl.style.left = (e.clientX - dragOffsetX) + 'px';
          ghostEl.style.top = (e.clientY - 20) + 'px';
        }

        const container = document.getElementById('bar-container');
        const wrappers = Array.from(container.querySelectorAll('.focus-wrapper:not(.being-dragged)'));

        // Find drop position
        let newDropIndex = orderedIds.length; // Default to end

        for (let i = 0; i < wrappers.length; i++) {
          const wrapper = wrappers[i];
          const rect = wrapper.getBoundingClientRect();
          const midX = rect.left + rect.width / 2;

          if (e.clientX < midX) {
            newDropIndex = orderedIds.indexOf(parseInt(wrapper.dataset.id));
            break;
          }
        }

        // Account for dragged item position
        const draggedIndex = orderedIds.indexOf(draggedId);
        if (newDropIndex > draggedIndex) {
          newDropIndex--;
        }

        // Update placeholder position if changed
        if (newDropIndex !== dropTargetIndex) {
          dropTargetIndex = newDropIndex;
          removePlaceholder();

          const placeholder = createPlaceholder();
          const allWrappers = Array.from(container.querySelectorAll('.focus-wrapper'));

          // Insert placeholder at correct position
          let insertBeforeEl = null;
          let count = 0;
          for (const w of allWrappers) {
            if (w.classList.contains('being-dragged')) continue;
            if (count === dropTargetIndex) {
              insertBeforeEl = w;
              break;
            }
            count++;
          }

          if (insertBeforeEl) {
            container.insertBefore(placeholder, insertBeforeEl);
          } else {
            container.appendChild(placeholder);
          }
        }
      }

      async function handleDragEnd() {
        const wasDragging = isDragging;
        const didReorder = draggedId !== null && isDragging && dropTargetIndex !== -1;

        if (didReorder) {
          // Apply the reorder
          const draggedIndex = orderedIds.indexOf(draggedId);
          if (draggedIndex !== -1 && draggedIndex !== dropTargetIndex) {
            orderedIds.splice(draggedIndex, 1);
            orderedIds.splice(dropTargetIndex, 0, draggedId);
          }
        }

        // Clean up
        removeGhost();
        removePlaceholder();
        dropTargetIndex = -1;
        draggedId = null;
        isDragging = false;
        document.body.style.cursor = '';

        // Prevent click from firing focus after drag
        if (wasDragging) {
          justFinishedDrag = true;
          setTimeout(() => { justFinishedDrag = false; }, 50);
        }

        // Only re-render and persist if we actually reordered
        if (didReorder) {
          render(true);  // Force recreate after reorder

          // Persist the new order to storage
          try {
            await invoke('reorder_reminders', { orderedIds });
            await emit('refresh-reminders');  // Sync to main window
          } catch (e) {
            console.error("Failed to persist order:", e);
          }
        }
      }

      function createCard(reminder, isFocused) {
        const wrapper = document.createElement('div');
        wrapper.className = `focus-wrapper${isFocused ? ' active' : ''}`;
        wrapper.dataset.id = reminder.id;

        const card = document.createElement('div');
        card.className = 'reminder-card';

        card.innerHTML = `
          <div class="card-content">
            <div class="card-message">${truncate(reminder.message, 30)}</div>
            <div class="card-time">${formatTime(reminder.due_time)}</div>
          </div>
          <div class="card-actions">
            <button class="card-btn snooze-inline" data-minutes="15" title="Snooze 15 min">15</button>
            <button class="card-btn snooze-inline" data-minutes="60" title="Snooze 1 hour">60</button>
            <button class="card-btn complete" title="Complete">&#10003;</button>
            <button class="card-btn dismiss" title="Dismiss">&#10005;</button>
          </div>
        `;

        // Event listeners
        card.addEventListener('mousedown', (e) => {
          if (e.target.closest('.card-actions')) return;
          handleDragStart(e, reminder.id);
        });

        card.addEventListener('click', (e) => {
          if (e.target.closest('.card-actions')) return;
          if (!isDragging && !justFinishedDrag) {
            handleFocus(reminder.id);
          }
        });

        // Tooltip on hover (only on card-content, not buttons)
        const cardContent = card.querySelector('.card-content');
        cardContent.addEventListener('mouseenter', (e) => {
          tooltipTimeout = setTimeout(() => {
            showTooltip(reminder, e.clientX, e.clientY);
          }, 400);  // Show after 400ms hover
        });

        cardContent.addEventListener('mouseleave', () => {
          hideTooltip();
        });

        cardContent.addEventListener('mousemove', (e) => {
          if (tooltipEl && tooltipEl.style.display === 'flex') {
            tooltipEl.style.left = Math.min(e.clientX, window.innerWidth - 320) + 'px';
          }
        });

        card.querySelector('.complete').addEventListener('click', () => handleComplete(reminder.id));
        card.querySelector('.dismiss').addEventListener('click', () => handleDismiss(reminder.id));

        card.querySelectorAll('.snooze-inline').forEach(btn => {
          btn.addEventListener('click', () => {
            handleSnooze(reminder.id, parseInt(btn.dataset.minutes));
          });
        });

        wrapper.appendChild(card);
        return wrapper;
      }

      function render(forceRecreate = false) {
        const container = document.getElementById('bar-container');

        // Toggle has-focus class based on whether any card is focused
        if (focusedId !== null) {
          container.classList.add('has-focus');
        } else {
          container.classList.remove('has-focus');
        }

        if (orderedIds.length === 0) {
          container.innerHTML = '<div class="empty-state">No reminders due</div>';
          return;
        }

        // Check if we can update in place (same cards, just focus change)
        const existingWrappers = container.querySelectorAll('.focus-wrapper');
        const existingIds = Array.from(existingWrappers).map(w => parseInt(w.dataset.id));
        const canUpdateInPlace = !forceRecreate &&
          existingIds.length === orderedIds.length &&
          existingIds.every((id, i) => id === orderedIds[i]);

        if (canUpdateInPlace) {
          // Just update active states - no DOM recreation
          existingWrappers.forEach(wrapper => {
            const id = parseInt(wrapper.dataset.id);
            if (focusedId === id) {
              wrapper.classList.add('active');
            } else {
              wrapper.classList.remove('active');
            }
          });
        } else {
          // Full rebuild needed
          container.innerHTML = '';
          for (const id of orderedIds) {
            const reminder = reminders.find(r => r.id === id);
            if (reminder) {
              container.appendChild(createCard(reminder, focusedId === id));
            }
          }
        }
      }

      function updateReminders(newReminders) {
        reminders = newReminders;

        // Use server's sort order - reminders come sorted by sort_order from backend
        const newIds = newReminders.map(r => r.id);
        const idsChanged = orderedIds.length !== newIds.length ||
          !orderedIds.every((id, i) => id === newIds[i]);
        orderedIds = newIds;

        // Clear focus if focused reminder no longer exists
        if (focusedId && !newIds.includes(focusedId)) {
          focusedId = null;
        }

        render(idsChanged);  // Force recreate if reminders added/removed
      }

      // Filter to only due reminders
      function filterDueReminders(allReminders) {
        const now = new Date();
        return allReminders.filter(r => {
          if (r.is_completed) return false;
          const dueTime = new Date(r.due_time);
          return dueTime <= now;
        });
      }

      // Fetch reminders directly from Rust backend
      async function fetchReminders() {
        try {
          const allPending = await invoke("get_pending_reminders");
          console.log("Fetched pending reminders:", allPending.length);
          const dueReminders = filterDueReminders(allPending);
          console.log("Due reminders:", dueReminders.length);
          updateReminders(dueReminders);
        } catch (e) {
          console.error("Failed to fetch reminders:", e);
        }
      }

      // Listen for updates from main window (for real-time updates after initial load)
      listen("update-reminders", (event) => {
        console.log("Received update-reminders:", event.payload);
        updateReminders(event.payload.reminders);
      });

      // Listen for refresh signal (after complete/snooze actions)
      listen("refresh-reminders", () => {
        console.log("Received refresh signal, fetching reminders");
        fetchReminders();
      });

      // Listen for focus events from main window
      listen("focus-reminder", (event) => {
        if (ignoreNextFocusEvent) {
          ignoreNextFocusEvent = false;
          return;
        }
        const newFocusId = event.payload.id;
        if (focusedId !== newFocusId) {
          focusedId = newFocusId;
          render();
        }
      });

      // Global mouse events for drag
      document.addEventListener('mousemove', handleDragMove);
      document.addEventListener('mouseup', handleDragEnd);

      // Initial load: fetch reminders directly
      render();
      fetchReminders();

      // Poll every second to catch newly due reminders in real-time
      setInterval(fetchReminders, 1000);

      // Smart reposition - only when monitor config might have changed
      let lastRepositionTime = 0;
      let repositionCooldown = 2000;  // Minimum 2 seconds between repositions
      let wasHidden = false;  // Track if we were actually hidden (not just unfocused)

      async function smartReposition(reason) {
        const now = Date.now();

        // Check cooldown
        if (now - lastRepositionTime < repositionCooldown) {
          log(`Reposition skipped (cooldown): ${reason}`, 'warn');
          return;
        }

        // Log current window state before reposition
        const beforeInfo = logWindowInfo();

        log(`Reposition triggered: ${reason}`);
        lastRepositionTime = now;

        try {
          await invoke('reposition_reminder_bar');
          // Log after to see what changed
          setTimeout(() => {
            const afterInfo = logWindowInfo();
            if (beforeInfo.screenX !== afterInfo.screenX || beforeInfo.screenY !== afterInfo.screenY) {
              log(`Position changed: (${beforeInfo.screenX},${beforeInfo.screenY}) -> (${afterInfo.screenX},${afterInfo.screenY})`);
            }
          }, 100);
        } catch (e) {
          log('Reposition failed: ' + e, 'error');
        }
      }

      // Only reposition when returning from hidden state (monitor sleep, minimized)
      document.addEventListener('visibilitychange', () => {
        if (document.visibilityState === 'hidden') {
          wasHidden = true;
          log('Visibility: hidden');
        } else if (document.visibilityState === 'visible' && wasHidden) {
          wasHidden = false;
          log('Visibility: restored from hidden');
          smartReposition('visibility restored');
        }
      });

      // DON'T reposition on every focus - this causes the freeze issue
      // Only log focus events for debugging
      window.addEventListener('focus', () => {
        log('Window focused (no reposition)');
      });

      window.addEventListener('blur', () => {
        log('Window blurred');
      });

      // Log initial position on load
      setTimeout(() => {
        log('Initial load complete');
        logWindowInfo();
      }, 500);
    </script>
  </body>
</html>
